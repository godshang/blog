
---
title: 'Redis 的持久化'
layout: post
categories: 技术
tags:
    - Redis
---

Redis是内存数据库，它把自己的数据库状态存储在内存中，所以一旦发生停电或者其他因素使主机宕机，那么数据将会丢失，所以Redis引入了持久化操作，它把Redis在内存中的数据库状态持久化到硬盘，当服务器重新启动的时候，去加载硬盘中的持久化文件就可恢复现场状态。

Redis有两种持久化方式:RDB持久化和AOF持久化，前者是通过把数据库状态的键值对保存起来，而AOF则是把命令保存起来，那么服务器是使用哪种持久化呢?因为AOF文件更新频率更高，所以优先AOF。

## RDB

RDB持久化可以将内存中的数据库状态保存到磁盘里面，避免数据意外丢失。

RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。

### RDB文件的创建与载入

有两个命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。

- SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。
- BGSAVE命令则会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。

RDB文件的载入是在服务器启动时自动执行的，没有专门用于载入RDB文件的命令，只要Redis服务器在启动时监测到RDB文件存在，它就会自动载入RDB文件。

另外，由于AOF文件的更新频率通常比RDB文件的更新频率高，所以：

- 如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。
- 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。

### SAVE命令执行时的服务器状态

当SAVE命令执行时，Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。只有在服务器执行完SAVE命令、重新开始接受命令请求之后，客户端发送的命令才会被处理。

### BASAVE命令执行时的服务器状态

由于BGSAVE命令的保存工作是由子进程执行的，所以在子进程创建RDB文件的过程中，Redis服务器仍然可以继续处理客户端的命令请求，但是，在BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令的方式和平时有所不同。

首先，在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE和BGSAVE同时执行时为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。

其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。

最后BGREWRITEAOF和BGSAVE两个命令不能同时执行：如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行。如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。

BGREWRITEAOF和BGSAVE都是由子进程执行，所有这个两个命令在操作方面并没有冲突的地方，不能同时执行只是一个性能方面的考虑——并发出两个字进程会导致同时执行大量的磁盘写入操作。

### RDB文件载入时的服务器状态

服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入完成。

### 自动间隔性保存

Redis允许通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。save选项可以设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。

例如：

```
save 900 1
save 300 30
save 60 100000
```

意味着只要服务器在900秒内对数据库进行了至少1次修改、或服务器在300秒之内对数据库进行了至少10次修改、或在60秒内对数据库进行了至少10000次修改，三个条件满足其中一个，BGSAVE就会被执行。

Redis服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就会执行BGSAVE命令。

```
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
	...

	// 遍历所有保存条件，看是否需要执行 BGSAVE 命令
     for (j = 0; j < server.saveparamslen; j++) {
        struct saveparam *sp = server.saveparams+j;

        /* Save if we reached the given amount of changes,
         * the given amount of seconds, and if the latest bgsave was
         * successful or if, in case of an error, at least
         * REDIS_BGSAVE_RETRY_DELAY seconds already elapsed. */
        // 检查是否有某个保存条件已经满足了
        if (server.dirty >= sp->changes &&
            server.unixtime-server.lastsave > sp->seconds &&
            (server.unixtime-server.lastbgsave_try >
             REDIS_BGSAVE_RETRY_DELAY ||
             server.lastbgsave_status == REDIS_OK))
        {
            redisLog(REDIS_NOTICE,"%d changes in %d seconds. Saving...",
                sp->changes, (int)sp->seconds);
            // 执行 BGSAVE
            rdbSaveBackground(server.rdb_filename);
            break;
        }
     }

    ...
```

## AOF

AOF（Append Only File）持久化通过保存Redis服务器所执行的写命令来记录数据库状态的。

被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，Redis的命令请求协议是纯文本格式的。

服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。

### AOF持久化的实现

AOF持久化的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。

#### 命令追加

当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。

#### 文件写入与同步

Redis的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像serverCron函数这样需要定时运行的函数。

服务器在每次结束一个事件循环之前，会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。

flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定：

- always：将aof_buf缓冲区中的所有内容写入并同步到AOF文件
- everysec：将aof_buf缓冲区中的所有内容写入到AOF文件，如果上次同步AOF文件的时间距离现在超过一秒钟，那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的。
- no：将aof_buf缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统来决定。

默认为everysec。

### AOF文件的载入与数据还原

因为AOF文件中包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。

Redis读取AOF文件并还原数据库状态的详细步骤如下：

1.	创建一个不带网络连接的伪客户端，因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所有服务器使用了一个没有网络连接的伪客户端来执行AOF文件中保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。
2.	从AOF文件中分析并读取出一条写命令。
3.	使用伪客户端执行被读出的写命令。
4.	一直执行步骤2和步骤3，知道AOF文件中的所有写命令都被处理完毕为止。

### AOF重写

因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过得AOF文件可能对Redis服务器、甚至整个宿主机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。

AOF文件重写正式为了解决这一问题的。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同个，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。

AOF文件重写不需要对现有的AOF文件进行任何读取、分析或者写入，而是通过读取服务器当前的数据库状态来实现的。

服务器首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。

在实际中，为了避免在执行时造成客户端输入缓冲区溢出，重写程序在处理链表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了REDIS_AOF_REWRITE_ITEMS_PER_CM常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。这个常量的值目前版本为64。

因为AOF重写过程会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞。因为Redis服务器使用单线程来处理命令请求，所以如果由服务器直接调用aof_rewrite函数的话，那么在重写期间，服务器将无法处理客户端发来的命令请求。因此，Redis将AOF重写程序放到子进程里执行，达到两个目的：

- 子进程进行AOF重写期间，服务器进程可以继续处理命令请求。
- 子集成带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。

但是，使用子进程进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。

为了解决这个问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子集成之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：

- 执行客户端发来的命令。
- 将执行后的写命令追加到AOF缓冲区。
- 将执行后的写命令追加到AOF重写缓冲区。
 
当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到信号之后，会调用一个信号处理函数，并执行以下工作：

1.	将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。
2.	对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。

这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接收命令请求了。

在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程造成阻塞。在其他时候，AOF后台重写都不会阻塞父进程。
