---
title: '套接字编程'
layout: post
categories: 技术
tags:
    - Socket
---

### socket函数 ###

为了执行网络I/O，一个进程必须做的第一件事情就是调用socket函数，指定期望的通信协议类型（使用IPv4的TCP、使用IPv6的UDP、Unix域字节流协议等）。

```c
    #include <sys/socket.h>

    int socket(int family, int type, int protocol);

    返回：若成功则为非负描述符，若出错则为-1
```

其中，family参数指明协议族，它是以下的某个常值：

- AF_INET：IPv4协议
- AF_INET6：IPv6协议
- AF_LOCAL：Unix域协议
- AF_ROUTE：路由套接字
- AF_KEY：秘钥套接字

type参数指明套接字类型，它是以下的某个常值：

- SOCK_STREAM：字节流套接字
- SOCK_DGRAM：数据报套接字
- SOCK_SEQPACKET：有序分组套接字
- SOCK_RAW：原始套接字

protocol参数应为以下的某个协议类型常值，或者设为0，以选择所给定的family和type组合的系统默认值：

- IPPROTO_CP：TCP传输协议
- IPPROTO_UDP：UDP传输协议
- IPPROTO_SCTP：SCTP传输协议

socket函数成功时返回一个非负整数，成为套接字描述符，简称sockfd。

### connect函数 ###

TCP客户用connect函数来建立与TCP服务器的连接。

```c
    #include <sys/socket.h>

    int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);

    返回：若成功则返回0，若出错则为-1
```

sockfd是由socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小。

客户在调用connect函数前不必非得调用bind函数，因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。

如果是TCP套接字，调用connect函数将激发TCP的三路握手过程，并且仅在链接建立成功或出错时才返回。

### bind函数 ###

bind函数把一个本地协议地址赋予一个套接字。对于网际网协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合。

```c
    #include <sys/socket.h>

    int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);

    返回：若成功则为0，若出错则为-1
```

第二个参数是一个指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度。对于TCP，调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定，还可以都不指定。

- 服务器在启动时捆绑它们的众所周知端口。如果一个TCP客户或服务器未曾调用bind捆绑一个端口，当调用connect或listen时，内核就要为响应的套接字选择一个临时端口。让内核选择临时端口对于TCP客户来说是正常的，除非应用需要一个预留端口；然而对于TCP服务器来说却极为罕见，因为服务器是通过众所周知端口向外提供服务。

- 进程可以把一个特定的IP地址捆绑到它的套接字中，不过这个IP地址必须属于其所在主机的网络接口之一。对于TCP客户，这就为在该套接字上发送的IP数据报指定了源IP地址。对于TCP服务器，这就限定了该套接字只接收那些目的地为这个IP地址的客户连接。

### listen函数 ###

listen函数仅由TCP服务器调用。当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是说，它是一个将调用connect函数发起连接的客户套接字。listen函数把一个未连接的套接字转换为一个被动套接字，指示内核应接受指向该套接字的连接请求。

```c
    #include <sys/socket.h>

    int listen(int sockfd, int backlog);

    返回：若成功则为0，若出错则为-1
```

listen函数第二个参数规定了内核应该为相应套接字排队的最大连接个数。内核为任何一个给定的监听套接字维护两个队列：

1. 未完成连接队列（incomplete connection queue），由某个客户发起的连接请求到达服务器后进入队列，服务器正在等待完成TCP三路握手过程。

2. 已完成连接队列（completed connection queue），每个完成TCP三路握手的客户对应队列中的一项。

### accept函数 ###

accept函数由TCP服务器调用，用于从已完成连接队列对头返回下一个已完成连接。如果已完成连接队列为空，那么进程将进入睡眠（假定套接字为默认的阻塞方式）。

```c
    #include <sys/socket.h>

    int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);

    返回：若成功则为非负描述符，若出错则为-1
```

参数cliaddr和addrlen用来返回已连接的对端进程（客户）的协议地址。addrlen是值-结果参数：调用前，将由addrlen指针引用的整数值置为由cliaddr所指套接字地址结构的长度；调用后，该整数值即为由内核存放在该套接字地址结构中的确切字节数。

如果accept成功，那么返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP客户。一般称accept函数的第一个参数为监听套接字描述符，称它的返回值为已连接套接字描述符。一个服务器通常仅创建一个监听套接字，它在该服务的生命周期内一直存在；当服务器完成对某个客户的请求时，响应的已连接套接字就被关闭。

### close函数 ###

close函数用来关闭套接字，并终止TCP连接。

```c
    #include <sys/socket.h>

    int close(int sockfd);

    返回：若成功则为0，若出错贼为-1
```

### getsockname和getpeername函数

getsockname函数返回与某个套接字关联的本地协议地址；getpeername函数返回与某个套接字关联的外地协议地址。

```c
    #include<sys/socket.h>

    int getsockname(int sockfd, struct sockaddr *localaddr, socklen_t *addrlen);

    int getpeername(int sockfd, struct sockaddr *peeraddr, socklen_t *addrlen);

    返回：若成功则为0，若出错则为-1
```

注意，这两个函数的最后一个参数都是值-结果参数。这就是说，这两个函数都得装填由localaddr或peeraddr指针所填的套接字地址结构。

## UDP套接字编程 ##

### recvfrom和sendto函数

这两个函数类似标准的read和write函数，不过需要三个额外的参数。

```c
    #include <sys/socket.h>

    ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t addrlen);

    ssize_t sendto(int sockfd, void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t *addrlen);

    返回：若成功则为读或写的字节数，若出错则为-1
```

前三个参数sockfd、buff和nbytes等同于read和write函数的三个参数：描述符、指向读入或写出缓冲区的指针和读写字节数。

sendto函数的to参数指向一个含有数据报接受者的协议地址（例如IP地址和端口号）的套接字地址结构，其大小由addrlen参数指定。recvfrom函数的from参数指向一个将由该函数在返回时填写的数据报发送者的协议地址的套接字地址结构，而在该套接字地址结构中填写的字节数则放在addrlen参数所指的整数中返回给调用者。注意，sendto的最后一个参数是一个整数值，而recvfrom的最后一个参数是一个指向整数值的指针（即值-结果参数）。