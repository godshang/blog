---
title: '排序'
layout: post
categories: 技术
tags:
    - Algorithm
---

## 算法模板

算法模板中定义了通用方法：

```
public abstract class AbstractSort<T extends Comparable> {

    public abstract void sort(T[] array);

    protected boolean less(T a, T b) {
        return a.compareTo(b) < 0;
    }

    protected void exch(T[] a, int i, int j) {
        T temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }

    protected void print(T[] a) {
        for (Comparable i : a) {
            System.out.print(i + " ");
        }
        System.out.println();
    }

}
```

## 选择排序

选择排序是一种简单直观的排序：首先，找到数组中最小的那个元素，其次，将它和数组中的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）；其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置；如此往复，直到将整个数组排序。

```
public class Selection extends AbstractSort {

    public <T> void sort(Comparable<T>[] a) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (less(a[j], a[min]))
                    min = j;
            }
            exch(a, i, min);
        }
    }
}
```

算法中内循环仅比较当前元素与最小元素，交换元素的代码在内循环外。每次交换都能排定一个元素，因此交换的总次数为N。所以算法的时间效率取决于比较的次数。

选择排序是一种很容易理解和实现的算法，有两个鲜明特点：

* 运行时间和输入无关。为了找出最下元素而扫描一遍数组并不能为下一遍扫描提供什么信息。一个已经有序的数组或者主键全部相等的数组，和一个元素随机排列的数组所用的排序时间一样长！
* 数据移动是最少的。每次交互都会改变连个数组元素的值，因此选择排序用了N此交换，即交换次数和数组的大小是线性关系。其他算法都不具备这个特征（大部分的增长量级都是线性对数或是平方级别）。

## 插入排序

插入排序类似整理扑克，将每一张牌插入到其他已经有序的牌中的适当位置。

与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被一定。但是当索引到达数组的右端时，数组排序就完成了。

和选择排序不同的是，插入排序所需的时间取决于输入元素的初始顺序。对一个很大的且其中的元素已经有序（或接近有序）的数组进行排序会比对随机顺序的数组或是逆序数据进行排序要快得多。


```
public class Insertion extends AbstractSort {

    @Override
    public void sort(Comparable[] array) {
        int length = array.length;
        for (int i = 1; i < length; i++) {
            Comparable t = array[i];
            for (int j = i; j > 0 && less(array[j], array[j - 1]); j--) {
                exch(array, j, j -1);
            }
        }
    }
}
```

## 希尔排序

对于大规模乱序数组，插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一段移动到另一端。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数据的局部进行排序，并最终用插入排序将局部有序的数组排序。

希尔排序的思想是使数组中任意间隔为h的元素都是有序的。

```
public class Shell extends AbstractSort {

    @Override
    public void sort(Comparable[] array) {
        int length = array.length;

        int h = 1;
        while (h < length / 3) {
            h = 3 * h + 1;
        }

        while (h >= 1) {
            for (int i = h; i < length; i++) {
                for (int j = i; j >= h && less(array[j], array[j - h]); j -= h) {
                    exch(array, j, j - h);
                }
            }
            h = h / 3;
        }
    }
}
```

希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。希尔排序高效的原因是它衡量了子数组的规模和有序性。排序之处，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。

## 归并排序

归并排序是将两个有序的数组归并程一个更大的有序数组，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。归并排序能够保证将任意长度为N的数组排序所需时间和NlogN成正比；它的主要缺点是所需额外空间和N成正比。

实现归并的一种直截了当的方法是将两个不同的有序数组归并到第三个数组中，实现方法很简单。但是，当用归并将一个大数组排序时，需要进行很多次归并，因此在每次归并时都创建一个新数组来存储排序结果会带来问题，因此更希望有一种能够在原地归并的方法，这样就可以先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的空间。

可以使用一个辅助数组，将涉及的所有元素复制到其中，再把归并的结果放会原数组中。

```
public class Merge extends AbstractSort {

    private Comparable[] aux;

    @Override
    public void sort(Comparable[] array) {
        aux = new Comparable[array.length];
        sort(array, 0, array.length - 1);
    }

    private void sort(Comparable[] array, int low, int high) {
        if (low >= high)
            return;

        int mid = low + (high - low) / 2;
        sort(array, low, mid);
        sort(array, mid + 1, high);
        merge(array, low, mid, high);
    }

    private void merge(Comparable[] array, int low, int mid, int high) {
        int i = low, j = mid + 1;

        for (int k = low; k <= high; k++)
            aux[k] = array[k];

        for (int k = low; k <= high; k++) {
            if (i > mid)
                array[k] = aux[j++];
            else if (j > high)
                array[k] = aux[i++];
            else if (less(aux[i], aux[j]))
                array[k] = aux[i++];
            else
                array[k] = aux[j++];
        }
    }
}
```

归并排序所需的时间和NlgN成正比。它表明只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序。

归并排序的主要缺点是辅助数组所使用的额外控件和N的大小成正比。

归并排序的一些优化：

* 对小规模子数组使用插入排序。因为递归会使小规模问题中方法的调用过于频繁，所以改进对小规模子数组的处理能改进整个算法。而插入排序在小数组上很可能比归并排序更快。
* 测试数组是否已经有序。可以添加一个判断条件，如果array[mid]小于等于array[mid + 1]，我们就认为数组是已经有序的并跳过merge方法。这个改动不影响排序的递归调用，但是任意有序的子数组算法的运行时间就变为线性的了。
* 不将元素复制到辅助数据。可以节省将数组元素复制到辅助数组所用的时间（但空间不行），要做到这一点，需要调用两种排序方法，一种将数据从输入数组排序到辅助数组，一种将数据从辅助数组排序到输入数组，需要在递归调用的每次层次交换输入数组和辅助数组的角色。

## 快速排序

快速排序是一种原地排序算法，只需要一个很小的辅助栈，且将长度为N的数组排序所需的时间和NlgN成正比。另外，快速排序的内循环比大多数排序算法都要小，这意味着它无论是在理论上还是再实际中都要更快。它的主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。许多错误都可能致使它在实际中的性能只有平房级别。

快速排序是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组有序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分为两半；在快速排序中，切分（partition）的位置取决于数组的内容。

```
public class Quick extends AbstractSort {

    @Override
    public void sort(Comparable[] array) {
        sort(array, 0, array.length - 1);
    }

    private void sort(Comparable[] array, int low, int high) {
        if (low >= high)
            return;

        int j = partition(array, low, high);
        sort(array, low, j - 1);
        sort(array, j + 1, high);
    }

    private int partition(Comparable[] array, int low, int high) {
        int i = low, j = high + 1;
        Comparable v = array[low];
        while (true) {
            while (less(array[++i], v))
                if (i == high) break;
            while (less(v, array[--j]))
                if (j == low) break;
            if (i >= j) break;
            exch(array, i, j);
        }
        exch(array, low, j);
        return j;
    }
}
```

有几个细节问题会导致实现错误或影响性能：

* 原地切分。如果使用一个辅助数组，我们可以很容易实现切分，但将切分后的数组复制回去的开销也许会得不偿失。甚至可能有人会将空数组创建在递归的切分方法中，这会大大降低排序的素。
* 别越界。如果切分元素时数组中最小或最大的那个元素，就要小心别让扫描指针跑出数组的边界。partition()实现可进行明确的监测来预防这种情况。
* 保持随机性。
* 终止循环。一个常见的错误是没有考虑到数组中可能包含和切分元素的值相同的其他元素。
* 处理切分元素值有重复的情况。左侧扫描最好是在遇到大雨等于切分元素值的元素时停下，右侧扫描则是遇到小于等于切分元素值的元素时停下。尽管这样可能会不必要地将一些等值的元素交换，但在某些场景下，能够避免算法的运行时间变为平方级别。
* 终止递归。

